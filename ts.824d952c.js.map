{"version":3,"sources":["ts/obstacles.ts","ts/player.ts","ts/collisions.ts","ts/game.ts","ts/index.ts"],"names":[],"mappings":";AAoCG,aAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EApCG,IAAA,EAuBJ,SAAY,EAAA,EAA4B,GAAY,IAAA,EAAA,KAAA,EAAA,KAAA,GAepD,KAAA,KAAO,WACG,IAAA,EAAuB,EAAvB,IAAK,EAAkB,EAAlB,MAAO,EAAW,EAAX,OACpB,EAAK,IAAI,YACT,EAAK,kBAAoB,EAAK,GAC9B,EAAK,IAAI,KAAK,EAAK,iBAAkB,EAAK,OAAO,OAAS,EAAQ,EAAO,GACzE,EAAI,UAAY,EAAK,UACrB,EAAI,OACJ,EAAK,IAAI,KAAK,EAAK,iBAAkB,EAAG,EAAO,EAAK,oBACpD,EAAI,UAAY,EAAK,UACrB,EAAI,OACJ,EAAI,YACJ,EAAK,EAAI,EAAK,MAAQ,EAAK,kBAG7B,KAAA,OAAS,SAAC,EAAW,GAEZ,OADe,EAAkB,EAAK,oBAAsB,EAAI,EAAK,OAAO,OAAS,EAAK,QA7B5F,KAAA,OAAS,EACT,KAAA,IAAM,EAAQ,WAAW,MACzB,KAAA,IAAM,KAAK,OAAO,MAAQ,IAC1B,KAAA,OAAS,KAAK,MAAO,KAAK,SAAW,KAAK,OAAO,OAAU,EAAI,IAC/D,KAAA,mBAAqB,KAAK,OAAO,OAAS,KAAK,OAAS,KAAK,OAAO,OAAS,EAE7E,KAAA,SAAU,EACV,KAAA,UAAoB,QAAA,OAAgB,IAAhB,KAAK,SAAmB,MAAA,OAAgB,IAAhB,KAAK,SAAmB,MAAA,OAAgB,IAAhB,KAAK,SAA9E,KACK,KAAA,WAAa,KAAK,OAAO,OAAS,KAAK,OACvC,KAAA,MAAQ,KAAK,OAAO,MAAQ,GAC5B,KAAA,iBAAmB,EACnB,KAAA,EAAI,KAAK,MAAQ,KAAK,kBAC5B,QAAA,QAAA;;ACXA,aAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAzBkB,IAAA,EAiBnB,SAAY,EAAA,EAA+B,EAA0B,EAAyB,GAAY,IAAA,EAAA,KAAA,EAAA,KAAA,GAU1G,KAAA,KAAO,WACG,IAAA,EAAiD,EAAjD,IAAK,EAA4C,EAA5C,iBAAkB,EAA0B,EAA1B,gBAAiB,EAAS,EAAT,KAChD,EAAK,IAAI,YACT,EAAK,IAAI,KAAK,EAAkB,EAAiB,EAAM,GACvD,EAAI,UAAY,MAChB,EAAI,OACJ,EAAI,YACJ,EAAK,iBAAmB,EAAK,GAC7B,EAAK,EAAI,EAAK,gBAAkB,EAAK,KACrC,EAAK,EAAI,EAAK,iBAAmB,EAAK,MAGxC,KAAA,KAAO,WACL,EAAK,IAAM,EACX,WAAW,WACT,EAAK,GAAK,KACT,MAzBE,KAAA,IAAM,EACN,KAAA,GAAK,IACL,KAAA,iBAAmB,EACnB,KAAA,EAAI,EAAkB,EACtB,KAAA,EAAI,EAAmB,EACvB,KAAA,gBAAkB,EAClB,KAAA,KAAO,GACb,QAAA,QAAA;;AC2DY,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAnFf,IAAA,EAAA,QAAA,eAmFe,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAjFT,IAAA,EAaJ,SAAY,EAAA,EAA2B,EAAgB,EAAoB,GAAa,IAAA,EAAA,KAAA,EAAA,KAAA,GAWxF,KAAA,MAAQ,WACE,IAAA,EAA4B,EAA5B,OAAQ,EAAoB,EAApB,QAAS,EAAW,EAAX,OACN,EAAb,SACN,QAAQ,IAAI,QACZ,EAAK,cAAc,EAAQ,GAC3B,EAAQ,QAAQ,SAAC,EAAmB,GAY9B,GAVA,EAAS,iBAAmB,EAAS,MAAQ,IAC/C,EAAK,QAAQ,OAAO,EAAO,GAC3B,EAAK,QAAQ,KAAK,IAAI,EAAJ,QAAY,EAAK,OAAQ,EAAK,OAAO,SAErD,EAAO,EAAI,EAAS,IAA0B,IAArB,EAAS,UAEpC,EAAS,SAAU,EACnB,EAAK,OAAS,IAGX,EAAS,OAAO,EAAO,EAAG,EAAO,iBAE5B,QAAA,GACD,KAAA,EAAO,EAAI,EAAS,mBAAyC,IAArB,EAAS,QAEpD,EAAS,SAAU,EACnB,EAAK,OAAS,EACd,MAEG,KAAA,EAAO,kBAAoB,EAAS,GAAK,EAAO,GAAK,EAAS,EAC9D,KAAA,EAAO,GAAK,EAAS,GAAK,EAAO,GAAK,EAAS,iBAC/C,KAAA,EAAO,IAAM,EAAS,iBACzB,EAAK,UAAW,MAY1B,KAAA,cAAgB,SAAC,EAA2B,GAEtC,EAAO,EAAI,EAAO,OACpB,EAAK,OAAO,GAAK,EACR,EAAO,gBAAkB,KAClC,EAAK,OAAO,GAAK,EACjB,WAAW,WAET,EAAK,OAAO,GAAK,KAChB,KAIP,KAAA,aAAe,SAAC,GAAsB,OAAA,EAAK,OAAO,IAAM,EAAS,kBAhE1D,KAAA,OAAS,EACT,KAAA,OAAS,EACT,KAAA,QAAU,EACV,KAAA,UAAW,EACX,KAAA,MAAQ,EACR,KAAA,UAAY,aAAa,OAAS,EAClC,KAAA,UAAY,KAAK,MAAQ,KAAK,UAAY,KAAK,MAAQ,KAAK,UACjE,aAAa,MAAQ,KAAK,WA4Df,EAAA,EAAA,QAAA,QAAA;;ACpDZ,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAhCH,IAAA,EAAA,QAAA,eACA,EAAA,EAAA,QAAA,aACA,EAAA,EAAA,QAAA,iBA8BG,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAXD,IAAA,EAAA,SAAY,EAAA,GAA0B,IAAA,EAAA,KAAA,EAAA,KAAA,GAJtC,KAAA,MAAgB,EAiBhB,KAAA,KAAO,WACL,EAAK,UAAW,EAChB,EAAK,OACL,EAAK,OAAO,iBAAiB,QAAS,EAAK,OAAO,OAKpD,KAAA,KAAO,WACG,IAAA,EAAkB,EAAlB,OAAQ,EAAU,EAAV,MAChB,EAAK,IAAI,UAAU,EAAG,EAAG,EAAO,GAEhC,EAAK,QAAQ,QAAQ,SAAC,GAAe,OAAA,EAAE,SACvC,EAAK,OAAO,OACN,IAAA,EAAU,IAAI,EAAJ,QAAe,EAAK,OAAQ,EAAK,OAAQ,EAAK,QAAS,EAAK,OAC5E,EAAQ,QACR,EAAK,MAAQ,EAAQ,MACrB,EAAK,IAAI,YACT,EAAK,IAAI,KAAK,EAAG,EAAG,EAAK,OAAO,MAAO,IACvC,EAAK,IAAI,WAAW,EAAG,EAAG,EAAK,OAAO,MAAO,IAE7C,EAAK,IAAI,UAAY,OACrB,EAAK,IAAI,OACT,EAAK,IAAI,KAAO,mBAChB,EAAK,IAAI,UAAY,UACrB,EAAK,IAAI,SAAsB,aAAA,OAAA,EAAQ,MAA0B,sBAAA,OAAA,EAAQ,WAAa,EAAG,IACzF,EAAK,SAAW,EAAQ,UACC,IAArB,EAAQ,UACV,sBAAsB,EAAK,OAxCxB,KAAA,OAAS,EACT,KAAA,IAAM,KAAK,OAAO,WAAW,MAC7B,KAAA,OAAS,IAAI,EAAJ,QAAW,KAAK,IAAK,IAAK,KAAK,OAAO,OAAS,EAAI,GAAI,IAChE,KAAA,QAAU,GACV,IAAA,IAAI,EAAI,EAAG,EAAI,EAAG,GAAK,EACrB,KAAA,QAAQ,KAAK,IAAI,EAAJ,QAAY,KAAK,OAAQ,KAAK,OAAO,MAAY,GAAJ,IAE5D,KAAA,UAAW,EACX,KAAA,OAAS,EAAQ,OACjB,KAAA,MAAQ,EAAQ,OACtB,QAAA,QAAA;;ACHH,aA7BA,IAAA,EAAA,EAAA,QAAA,WA6BA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GA3BA,IAAM,EAAS,SAAS,cAAc,WAChC,EAAY,SAAS,cAAc,cACrC,EAAO,IAAI,EAAJ,QAAS,GACpB,EAAO,iBAAiB,QAAS,YACT,IAAlB,EAAK,WACP,EAAO,IAAI,EAAJ,QAAS,IACX","file":"ts.824d952c.js","sourceRoot":"../src","sourcesContent":["class PILLARS {\n  canvas: HTMLCanvasElement;\n\n  ctx: CanvasRenderingContext2D;\n\n  distanceFromLeft: number;\n\n  dl: number;\n\n  height: number;\n\n  secondPillarHeight: number;\n\n  safeHeight: number;\n\n  width: number;\n\n  x: number;\n\n  counted: boolean;\n\n  fillStyle: string;\n\n  constructor(_canvas: HTMLCanvasElement, left: number) {\n    this.canvas = _canvas;\n    this.ctx = _canvas.getContext('2d')!;\n    this.dl = -this.canvas.width / 400;\n    this.height = Math.floor((Math.random() * this.canvas.height) / 4 + 50);\n    this.secondPillarHeight = this.canvas.height - this.height - this.canvas.height / 4;\n\n    this.counted = false;\n    this.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255})`;\n    this.safeHeight = this.canvas.height - this.height;\n    this.width = this.canvas.width / 14;\n    this.distanceFromLeft = left;\n    this.x = this.width + this.distanceFromLeft;\n  }\n\n  draw = () => {\n    const { ctx, width, height } = this;\n    this.ctx.beginPath();\n    this.distanceFromLeft += this.dl;\n    this.ctx.rect(this.distanceFromLeft, this.canvas.height - height, width, height);\n    ctx.fillStyle = this.fillStyle;\n    ctx.fill();\n    this.ctx.rect(this.distanceFromLeft, 0, width, this.secondPillarHeight);\n    ctx.fillStyle = this.fillStyle;\n    ctx.fill();\n    ctx.closePath();\n    this.x = this.width + this.distanceFromLeft;\n  };\n\n  isSafe = (y: number, distanceFromTop: number) => {\n    const bool: boolean = distanceFromTop > this.secondPillarHeight && y < this.canvas.height - this.height;\n    return bool;\n  };\n}\n\nexport { PILLARS };\n","export default class PLAYER {\n  ctx: CanvasRenderingContext2D;\n\n  distanceFromLeft: number;\n\n  // used when rendering\n  distanceFromTop: number;\n\n  size: number;\n\n  dy: number;\n\n  // used when checking for collisions\n  y: number;\n\n  x: number;\n\n  constructor(ctx: CanvasRenderingContext2D, distanceFromLeft: number, distanceFromTop: number, size: number) {\n    this.ctx = ctx;\n    this.dy = 1.2;\n    this.distanceFromLeft = distanceFromLeft;\n    this.y = distanceFromTop + size;\n    this.x = distanceFromLeft + size;\n    this.distanceFromTop = distanceFromTop;\n    this.size = size;\n  }\n\n  draw = () => {\n    const { ctx, distanceFromLeft, distanceFromTop, size } = this;\n    this.ctx.beginPath();\n    this.ctx.rect(distanceFromLeft, distanceFromTop, size, size);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    ctx.closePath();\n    this.distanceFromTop += this.dy;\n    this.y = this.distanceFromTop + this.size;\n    this.x = this.distanceFromLeft + this.size;\n  };\n\n  jump = () => {\n    this.dy = -2;\n    setTimeout(() => {\n      this.dy = 1.2;\n    }, 300);\n  };\n}\n","import PLAYER from './player';\nimport { PILLARS } from './obstacles';\n\nclass COLLISIONS {\n  canvas!: HTMLCanvasElement;\n\n  player!: PLAYER;\n\n  pillars!: PILLARS[];\n\n  gameOver!: boolean;\n\n  score: number;\n\n  highScore: number;\n\n  constructor(canvas: HTMLCanvasElement, player: PLAYER, pillars: PILLARS[], score: number) {\n    this.canvas = canvas;\n    this.player = player;\n    this.pillars = pillars;\n    this.gameOver = false;\n    this.score = score;\n    this.highScore = localStorage.score || 0;\n    this.highScore = this.score > this.highScore ? this.score : this.highScore;\n    localStorage.score = this.highScore;\n  }\n\n  check = () => {\n    const { canvas, pillars, player } = this;\n    let { gameOver } = this;\n    console.log('test');\n    this.boundaryCheck(canvas, player);\n    pillars.forEach((obstacle: PILLARS, index: number) => {\n      // Constantly replace pillars as they hit the screen boundary\n      if (obstacle.distanceFromLeft + obstacle.width < 0) {\n        this.pillars.splice(index, 1);\n        this.pillars.push(new PILLARS(this.canvas, this.canvas.width));\n      }\n      if (player.x > obstacle.x && obstacle.counted === false) {\n        // eslint-disable-next-line no-param-reassign\n        obstacle.counted = true;\n        this.score += 1;\n      }\n      //   Check if player is inside the space between pillars\n      if (!obstacle.isSafe(player.y, player.distanceFromTop)) {\n        // Then check if player is hitting said pillars\n        switch (true) {\n          case player.x > obstacle.distanceFromLeft && obstacle.counted === false: {\n            // eslint-disable-next-line no-param-reassign\n            obstacle.counted = true;\n            this.score += 1;\n            break;\n          }\n          case player.distanceFromLeft <= obstacle.x && player.x >= obstacle.x:\n          case player.x <= obstacle.x && player.x >= obstacle.distanceFromLeft:\n          case player.x === obstacle.distanceFromLeft: {\n            this.gameOver = true;\n            break;\n          }\n\n          default:\n            break;\n        }\n        // if (player.x > obstacle.distanceFromLeft) this.score += 1;\n      }\n    });\n  };\n\n  boundaryCheck = (canvas: HTMLCanvasElement, player: PLAYER) => {\n    // If the square is at the top of the canvas, go no further\n    if (player.y > canvas.height) {\n      this.player.dy = 0;\n    } else if (player.distanceFromTop < 25) {\n      this.player.dy = 0;\n      setTimeout(() => {\n        // Do this because otherwise the player gets stuck on the top of the canvas\n        this.player.dy = 1.2;\n      }, 5);\n    }\n  };\n\n  collidesLeft = (obstacle: PILLARS) => this.player.x === obstacle.distanceFromLeft;\n}\n\nexport default COLLISIONS;\n","import { PILLARS } from './obstacles';\nimport PLAYER from './player';\nimport COLLISIONS from './collisions';\n\nexport default class {\n  canvas: HTMLCanvasElement;\n\n  ctx: CanvasRenderingContext2D;\n\n  player: PLAYER;\n\n  pillars: PILLARS[];\n\n  height: number;\n\n  width: number;\n\n  score: number = 0;\n\n  gameOver: boolean;\n\n  constructor(_canvas: HTMLCanvasElement) {\n    this.canvas = _canvas;\n    this.ctx = this.canvas.getContext('2d')!;\n    this.player = new PLAYER(this.ctx, 120, this.canvas.height / 2 + 12, 12);\n    this.pillars = [];\n    for (let i = 0; i < 6; i += 1) {\n      this.pillars.push(new PILLARS(this.canvas, this.canvas.width + i * 69));\n    }\n    this.gameOver = true;\n    this.height = _canvas.height;\n    this.width = _canvas.width;\n  }\n\n  init = () => {\n    this.gameOver = false;\n    this.loop();\n    this.canvas.addEventListener('click', this.player.jump);\n    // this.canvas.addEventListener('touchstart', this.player.jump);\n  };\n\n  // The game loop\n  loop = () => {\n    const { height, width } = this;\n    this.ctx.clearRect(0, 0, width, height);\n\n    this.pillars.forEach((p: PILLARS) => p.draw());\n    this.player.draw();\n    const checker = new COLLISIONS(this.canvas, this.player, this.pillars, this.score);\n    checker.check();\n    this.score = checker.score;\n    this.ctx.beginPath();\n    this.ctx.rect(0, 0, this.canvas.width, 25);\n    this.ctx.strokeRect(0, 0, this.canvas.width, 25);\n\n    this.ctx.fillStyle = '#eee';\n    this.ctx.fill();\n    this.ctx.font = '1.2rem monospace';\n    this.ctx.fillStyle = '#454545';\n    this.ctx.fillText(`Score is: ${checker.score} | High score is: ${checker.highScore}`, 5, 18);\n    this.gameOver = checker.gameOver;\n    if (checker.gameOver === false) {\n      requestAnimationFrame(this.loop);\n\n      // document.querySelector('#score')!.textContent = `Score is: ${checker.score}`;\n    }\n  };\n}\n","import GAME from './game';\n\nconst canvas = document.querySelector('#canvas') as HTMLCanvasElement;\nconst container = document.querySelector('.container') as Element;\nlet game = new GAME(canvas);\ncanvas.addEventListener('click', () => {\n  if (game.gameOver === true) {\n    game = new GAME(canvas);\n    game.init();\n  }\n});\n// const score = document.querySelector('button') as Element;\n// score.addEventListener(\n//   'click',\n//   () => {\n//     // This nesting is a bit out of hand\n//     score.textContent = 'Pause Game';\n\n//     game.init();\n//     score.addEventListener('click', () => {\n//       game.paused = !game.paused;\n//       score.textContent = 'Resume Game';\n//       score.addEventListener('click', () => {\n//         score.textContent = game.paused === true ? 'Resume Game' : 'Pause Game';\n//         game.loop();\n//       });\n//     });\n//   },\n//   { once: true },\n// );\n"]}